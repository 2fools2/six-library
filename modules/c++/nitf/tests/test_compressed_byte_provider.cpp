/* =========================================================================
 * This file is part of six.sidd-c++
 * =========================================================================
 *
 * (C) Copyright 2004 - 2018, MDA Information Systems LLC
 *
 * six.sidd-c++ is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; If not,
 * see <http://www.gnu.org/licenses/>.
 *
 */

// Demonstrates that the raw bytes provided by this class result in equivalent
// SIDDs to the normal writes via NITFWriteControl

#include <iostream>
#include <limits>
#include <stdlib.h>

#include <io/FileOutputStream.h>
#include <io/ReadUtils.h>
#include <math/Round.h>
#include <mem/ScopedArray.h>
#include <mem/SharedPtr.h>
#include <nitf/CompressedByteProvider.hpp>
#include <nitf/ImageWriter.hpp>
#include <nitf/WriteHandler.hpp>
#include <nitf/IOHandle.hpp>
#include <nitf/IOStreamWriter.hpp>
#include <nitf/Reader.hpp>
#include <nitf/Utils.hpp>
#include <nitf/Writer.hpp>
#include <types/RowCol.h>

namespace
{
void setCornersFromDMSBox(nitf::ImageSubheader& header)
{
    /*
     *  You could do this in degrees as easily
     *  but this way we get to show off some new utilities
     */
    int latTopDMS[3]    = { 42, 17, 50 };
    int latBottomDMS[3] = { 42, 15, 14 };
    int lonEastDMS[3]   = { -83, 42, 12 };
    int lonWestDMS[3]   = { -83, 45, 44 };

    double latTopDecimal =
        nitf::Utils::geographicToDecimal(latTopDMS[0],
                                         latTopDMS[1],
                                         latTopDMS[2]);

    double latBottomDecimal =
        nitf::Utils::geographicToDecimal(latBottomDMS[0],
                                         latBottomDMS[1],
                                         latBottomDMS[2]);

    double lonEastDecimal =
        nitf::Utils::geographicToDecimal(lonEastDMS[0],
                                         lonEastDMS[1],
                                         lonEastDMS[2]);


    double lonWestDecimal =
        nitf::Utils::geographicToDecimal(lonWestDMS[0],
                                         lonWestDMS[1],
                                         lonWestDMS[2]);

    double corners[4][2];
    corners[0][0] = latTopDecimal;     corners[0][1] = lonWestDecimal;
    corners[1][0] = latTopDecimal;     corners[1][1] = lonEastDecimal;
    corners[2][0] = latBottomDecimal;  corners[2][1] = lonEastDecimal;
    corners[3][0] = latBottomDecimal;  corners[3][1] = lonWestDecimal;

    header.setCornersFromLatLons(NITF_CORNERS_DECIMAL, corners);
}

void addImageSegment(nitf::Record& record,
        size_t numRows,
        size_t numCols,
        size_t rowsPerBlock,
        size_t colsPerBlock,
        size_t bytesPerPixel)
{
    nitf::ImageSegment segment = record.newImageSegment();
    nitf::ImageSubheader header = segment.getSubheader();

    header.getImageId().set("NITRO-TEST");
    header.getImageDateAndTime().set("20080812000000");

    /* Set the geo-corners to Ann Arbor, MI */
    setCornersFromDMSBox(header);

    std::vector<nitf::BandInfo> bands(1, nitf::BandInfo());
    bands[0].init("R",        /* The band representation, Nth band */
                   " ",       /* The band subcategory */
                   "N",       /* The band filter condition */
                   "   ");    /* The band standard image filter code */


    const std::string iRep = "MONO";
    header.setPixelInformation("INT",     /* Pixel value type */
                               8 * bytesPerPixel, /* Number of bits/pixel */
                               8 * bytesPerPixel, /* Actual number of bits/pixel */
                               "R",       /* Pixel justification */
                               iRep,      /* Image representation */
                               "VIS",     /* Image category */
                               bands);    /* Band information object list */



    /* for fun, let's add a comment */
    header.insertImageComment("NITF generated by NITRO", 0);

    header.setBlocking(numRows,
                       numCols,
                       std::min(numRows, rowsPerBlock),
                       colsPerBlock,
                       "B");               /*!< Image mode */
}



// Make sure a file gets removed
class EnsureFileCleanup
{
public:
    EnsureFileCleanup(const std::string& pathname) :
        mPathname(pathname)
    {
        removeIfExists();
    }

    ~EnsureFileCleanup()
    {
        try
        {
            removeIfExists();
        }
        catch (...)
        {
        }
    }

private:
    void removeIfExists()
    {
        sys::OS os;
        if (os.exists(mPathname))
        {
            os.remove(mPathname);
        }
    }

    const std::string mPathname;

};

class CompareFiles
{
public:
    CompareFiles(const std::string& lhsPathname) :
        mLHS(0, 1)
    {
        readImage(lhsPathname, mLHS);
    }

    bool operator()(const std::string& prefix,
                    const std::string& rhsPathname) const
    {
        readImage(rhsPathname, mRHS);
        if (mLHS == mRHS)
        {
            std::cout << prefix << " matches" << std::endl;
            return true;
        }
        else if (mLHS.size() != mRHS.size())
        {
            std::cerr << prefix << " DOES NOT MATCH: file sizes are "
                      << mLHS.size() << " vs. " << mRHS.size() << " bytes"
                      << std::endl;
        }
        else
        {
            size_t ii;
            for (ii = 0; ii < mLHS.size(); ++ii)
            {
                if (mLHS[ii] != mRHS[ii])
                {
                    std::cerr << prefix << " DOES NOT MATCH at byte " << ii
                        << std::endl;
                    break;
                }
            }
        }
        return false;
    }
private:
    std::vector<sys::byte> mLHS;
    mutable std::vector<sys::byte> mRHS;
    static void readImage(const std::string& pathname, std::vector<sys::byte>& data);
};

void CompareFiles::readImage(const std::string& pathname,
                             std::vector<sys::byte>& data)
{
    data.clear();
    nitf::Reader reader;
    nitf::IOHandle io(pathname);
    nitf::Record record = reader.read(io);
    nitf::ListIterator iter = record.getImages().begin();
    size_t image = 0;
    size_t imageOffset = 0;
    for (;iter != record.getImages().end(); ++iter)
    {
        nitf::ImageReader imageReader = reader.newImageReader(image);
        nitf::ImageSegment imageSegment = *iter;
        nitf::ImageSubheader imageSubheader = imageSegment.getSubheader();
        const size_t numBlocks =
                static_cast<size_t>(imageSubheader.getNumBlocksPerRow()) *
                static_cast<size_t>(imageSubheader.getNumBlocksPerCol());
        const size_t imageLength = imageSubheader.getNumBytesOfImageData();
        data.resize(imageOffset + imageLength);

        nitf::Uint64 blockOffset = 0;
        for (size_t block = 0; block < numBlocks; ++block)
        {
            // Read a block
            nitf::Uint64 bytesThisBlock(0);
            const nitf::Uint8* blockData =
                imageReader.readBlock(block, &bytesThisBlock);
            if (bytesThisBlock == 0)
            {
                throw except::Exception(Ctxt("Failed to read block"));
            }

            // Copy it to the output
            memcpy(&data[imageOffset + blockOffset],
                    blockData,
                    bytesThisBlock);
            blockOffset += bytesThisBlock;
        }
        imageOffset += imageLength;
        ++image;
    }
}

// Main test class
template <typename DataTypeT>
class Tester
{
public:
    Tester(size_t numRowsPerBlock,
           size_t numColsPerBlock,
           bool setMaxProductSize,
           size_t maxRowsPerSegment) :
        mNormalPathname("normal_write.nitf"),
        mNormalFileCleanup(mNormalPathname),
        mSetMaxProductSize(setMaxProductSize),
        mMaxRowsPerSegment(maxRowsPerSegment),
        mTestPathname("streaming_write.nitf"),
        mSuccess(true)
    {
        // Generate test image
        const types::RowCol<size_t> globalImageDims(123, 56);
        mImage.resize(globalImageDims.area());
        srand(334);
        for (size_t ii = 0; ii < mImage.size(); ++ii)
        {
            mImage[ii] = static_cast<DataTypeT>(
                    rand() % std::numeric_limits<DataTypeT>::max());
        }

        // Set segmenting dimensions
        mNumImages = 1;
        if (mSetMaxProductSize)
        {
            mNumImages = math::ceilingDivide(globalImageDims.row,
                                             mMaxRowsPerSegment);
        }

        mDims.resize(mNumImages);
        for (size_t ii = 0; ii < mNumImages; ++ii)
        {
            mDims[ii].col = globalImageDims.col;
            if (ii == mNumImages - 1)
            {
                mDims[ii].row = globalImageDims.row - ii * mMaxRowsPerSegment;
            }
            else
            {
                mDims[ii].row = mMaxRowsPerSegment;
            }
        }

        mBlockDims.row = (numRowsPerBlock == 0) ? mDims[0].row : numRowsPerBlock;
        mBlockDims.col = (numColsPerBlock == 0) ? mDims[0].col : numColsPerBlock;

        // Set up source data
        normalWrite();
        mCompareFiles.reset(new CompareFiles(mNormalPathname));

        // Pre-compress image data
        createCompressedImage();
    }

    void testSingleWrite();
    void testMultipleWritesBlocked();

    bool success() const
    {
        return mSuccess;
    }

private:
    void normalWrite() const;
    void populateRecord(const std::string& pathname,
                        nitf::Record& record) const;
    void createCompressedImage();

    void compressImageSegment(
            size_t imageNumber,
            const nitf::ImageBlocker& imageBlocker,
            mem::ScopedArray<std::vector<sys::byte> >& compressedBlocks,
            std::vector<size_t>& bytesPerBlock);

    void write(nitf::Off fileOffset,
               const nitf::NITFBufferList& buffers,
               nitf::Off computeNumBytes,
               io::FileOutputStream& outStream);

    size_t rowsToPixels(size_t rows) const
    {
        return rows * mDims[0].col * sizeof(DataTypeT);
    }

    std::string getSuffix() const
    {
        std::string suffix;
        if (mBlockDims.area() != 0 && mBlockDims != mDims[0])
        {
            suffix += " with blocking of rows/block=" +
                str::toString(mBlockDims.row) +
                ", cols/block=" +
                str::toString(mBlockDims.col);
        }
        return suffix;
    }

    void compare(const std::string& prefix)
    {
        std::string fullPrefix = prefix;
        if (mSetMaxProductSize)
        {
            fullPrefix += " (max rows per image " +
                str::toString(mMaxRowsPerSegment) + ")";
        }
        fullPrefix += getSuffix();
        if (!(*mCompareFiles)(fullPrefix, mTestPathname))
        {
            mSuccess = false;
        }
    }

private:
    const std::string mNormalPathname;
    const EnsureFileCleanup mNormalFileCleanup;

    std::vector<types::RowCol<size_t> > mDims;
    types::RowCol<size_t> mBlockDims;
    const bool mSetMaxProductSize;
    const size_t mMaxRowsPerSegment;
    const std::string mTestPathname;
    std::vector<DataTypeT> mImage;
    size_t mNumImages;

    mem::ScopedArray<mem::ScopedArray<std::vector<sys::byte> > >mCompressedBlocks;
    std::vector<std::vector<size_t> > mBytesPerBlock;
    std::auto_ptr<const CompareFiles> mCompareFiles;
    bool mSuccess;
};


template<typename DataTypeT>
void Tester<DataTypeT>::createCompressedImage()
{
    std::vector<size_t> rowsEachSegment(mNumImages, 0);
    for (size_t image = 0; image < mNumImages; ++image)
    {
        rowsEachSegment[image] = mDims[image].row;
    }
    nitf::ImageBlocker imageBlocker(
            rowsEachSegment, mDims[0].col, mBlockDims.row, mBlockDims.col);

    mBytesPerBlock.resize(mNumImages);
    for (size_t image = 0; image < mBytesPerBlock.size(); ++image)
    {
        const size_t numBlocks =
                imageBlocker.getNumRowsOfBlocks(image) *
                imageBlocker.getNumColsOfBlocks();

        mBytesPerBlock[image].resize(numBlocks);
    }

    mCompressedBlocks.reset(
            new mem::ScopedArray<std::vector<sys::byte> >[mNumImages]);

    for (size_t image = 0; image < mNumImages; ++image)
    {
        const size_t numBlocks = mBytesPerBlock[image].size();
        mCompressedBlocks[image].reset(
                new std::vector<sys::byte>[numBlocks]);

        compressImageSegment(
                image,
                imageBlocker,
                mCompressedBlocks[image],
                mBytesPerBlock[image]);
    }
}

template<typename DataTypeT>
void Tester<DataTypeT>::write(
        nitf::Off fileOffset,
        const nitf::NITFBufferList& buffers,
        nitf::Off computeNumBytes,
        io::FileOutputStream& outStream)
{
    outStream.seek(fileOffset, io::Seekable::START);

    nitf::Off numBytes = 0;
    for (size_t ii = 0; ii < buffers.mBuffers.size(); ++ii)
    {
        outStream.write(
                static_cast<const sys::byte*>(buffers.mBuffers[ii].mData),
                buffers.mBuffers[ii].mNumBytes);
        numBytes += buffers.mBuffers[ii].mNumBytes;
    }

    if (numBytes != computeNumBytes)
    {
        std::cerr << "Computed " << computeNumBytes
                  << " bytes but actually had " << numBytes << " bytes"
                  << std::endl;
        mSuccess = false;
    }
}

template<typename DataTypeT>
void Tester<DataTypeT>::populateRecord(
        const std::string& pathname,
        nitf::Record& record) const
{
    nitf::FileHeader header = record.getHeader();
    header.getOriginStationID().set("github.com");
    header.getFileTitle().set(pathname);

    for (size_t ii = 0; ii < mNumImages; ++ii)
    {
        addImageSegment(record,
            mDims[ii].row, mDims[ii].col,
            mBlockDims.row, mBlockDims.col,
            sizeof(DataTypeT));
    }
}

template<typename DataTypeT>
void Tester<DataTypeT>::normalWrite() const
{
    nitf::IOHandle handle(mNormalPathname,
            NITF_ACCESS_WRITEONLY, NITF_CREATE);
    nitf::Writer writer;
    nitf::Record record;
    populateRecord(mNormalPathname, record);
    writer.prepare(handle, record);

    std::vector<nitf::ImageWriter> imageWriters;
    for (size_t ii = 0; ii < mNumImages; ++ii)
    {
        imageWriters.push_back(writer.newImageWriter(ii));
        const size_t area = rowsToPixels(mDims[ii].row);
        const size_t offset = rowsToPixels(ii * mMaxRowsPerSegment);
        nitf::BandSource bandSource = nitf::MemorySource(
                reinterpret_cast<const char*>(&mImage[0]),
                area, offset, sizeof(DataTypeT), 0);
        nitf::ImageSource imageSource;
        imageSource.addBand(bandSource);

        imageWriters[ii].setWriteCaching(1);
        imageWriters[ii].attachSource(imageSource);
    }
    writer.write();
}

template<typename DataTypeT>
void Tester<DataTypeT>::compressImageSegment(
     size_t imageNumber,
     const nitf::ImageBlocker& imageBlocker,
     mem::ScopedArray<std::vector<sys::byte> >& compressedBlocks,
     std::vector<size_t>& bytesPerBlock)
{
    const types::RowCol<size_t>& imageDims = mDims[imageNumber];
    size_t rowsWritten = 0;
    for (size_t image = 0; image < imageNumber; ++image)
    {
        rowsWritten += mDims[image].row;
    }

    const size_t imageStartRow = rowsWritten;
    for (size_t block = 0; block < bytesPerBlock.size(); ++block)
    {
        const size_t startRow = rowsWritten;
        const size_t pixelOffset = startRow * imageDims.col;
        const size_t lastRowThisImage = imageStartRow + imageDims.row;

        const size_t numRows =
                std::min<size_t>(imageBlocker.getNumRowsPerBlock()[imageNumber],
                                 lastRowThisImage - startRow);

        const size_t bytesInBlock = imageBlocker.getNumBytesRequired(
                startRow, numRows, sizeof(DataTypeT));
        mem::ScopedArray<sys::ubyte> blockData(new sys::ubyte[bytesInBlock]);
        imageBlocker.block(&mImage[pixelOffset],
                startRow, numRows, sizeof(DataTypeT), blockData.get());

        // If we had a compressor, you would call it here.
        // There isn't one, so just copying the data over
        compressedBlocks[block].resize(bytesInBlock);
        memcpy(&(compressedBlocks[block][0]), blockData.get(), bytesInBlock);
        bytesPerBlock[block] = compressedBlocks[block].size();

        rowsWritten += numRows;
    }
}

template<typename DataTypeT>
void Tester<DataTypeT>::testSingleWrite()
{
    EnsureFileCleanup test(mTestPathname);
    nitf::Record record;
    populateRecord(mNormalPathname, record);

    std::vector<nitf::ByteProvider::PtrAndLength> desData;
    nitf::CompressedByteProvider byteProvider(record, mBytesPerBlock,
            desData, mBlockDims.row, mBlockDims.col,
            mSetMaxProductSize ? mMaxRowsPerSegment : 0);

    size_t totalNumBytes = 0;
    for (size_t image = 0; image < mNumImages; ++image)
    {
        for (size_t block = 0; block < mBytesPerBlock[image].size(); ++block)
        {
            totalNumBytes += mBytesPerBlock[image][block];
        }
    }

    mem::ScopedArray<sys::byte> combinedCompressedBlocks(
            new sys::byte[totalNumBytes]);
    size_t offset = 0;
    size_t totalNumRows = 0;
    for (size_t image = 0; image < mNumImages; ++image)
    {
        totalNumRows += mDims[image].row;
        const std::vector<size_t>& bytesPerBlock = mBytesPerBlock[image];
        for (size_t block = 0; block < bytesPerBlock.size(); ++block)
        {
            sys::byte* dest = &combinedCompressedBlocks[offset];
            const sys::byte* source = &(mCompressedBlocks[image][block][0]);
            memcpy(dest, source, bytesPerBlock[block]);
            offset += bytesPerBlock[block];
        }
    }

    nitf::Off fileOffset;
    nitf::NITFBufferList buffers;
    byteProvider.getBytes(&combinedCompressedBlocks[0],
                          0, totalNumRows, fileOffset, buffers);

    io::FileOutputStream outputStream(mTestPathname);
    const nitf::Off expectedNumBytes = byteProvider.getNumBytes(0, totalNumRows);
    write(fileOffset, buffers, expectedNumBytes, outputStream);

    compare("Single write");

}

template<typename DataTypeT>
void Tester<DataTypeT>::testMultipleWritesBlocked()
{
    EnsureFileCleanup test(mTestPathname);
    nitf::Record record;
    populateRecord(mNormalPathname, record);

    std::vector<nitf::ByteProvider::PtrAndLength> desData;
    nitf::CompressedByteProvider byteProvider(record, mBytesPerBlock,
            desData, mBlockDims.row, mBlockDims.col,
            mSetMaxProductSize ? mMaxRowsPerSegment : 0);

    io::FileOutputStream outputStream(mTestPathname);

    size_t startRow = 0;
    for (size_t image = 0; image < mNumImages; ++image)
    {
        const size_t blocksThisSegment = mBytesPerBlock[image].size();
        const size_t rowsLastBlock = mDims[image].row -
            mBlockDims.row * (blocksThisSegment - 1);

        for (size_t block = 0; block < blocksThisSegment; ++block)
        {
            const size_t numRows = (block == blocksThisSegment - 1) ?
                    rowsLastBlock : mBlockDims.row;

            nitf::Off fileOffset;
            nitf::NITFBufferList buffers;
            byteProvider.getBytes(&(mCompressedBlocks[image][block][0]),
                    startRow, numRows, fileOffset, buffers);

            nitf::Off expectedNumBytes = byteProvider.getNumBytes(startRow, numRows);
            write(fileOffset, buffers, expectedNumBytes, outputStream);
            startRow += numRows;
        }
    }
    compare("Multiple writes blocked");
}

template<typename DataTypeT>
bool doTests(bool setBlocking,
             bool setMaxProductSize,
             size_t maxRowsPerSegment)
{
    // These intentionally do not divide evenly so there will be both pad rows
    // and cols
    const size_t numRowsPerBlock = setBlocking ? 40: 0;
    const size_t numColsPerBlock = 0;

    Tester<DataTypeT> tester(numRowsPerBlock,
                             numColsPerBlock,
                             setMaxProductSize,
                             maxRowsPerSegment);

    if (setBlocking)
    {
        tester.testMultipleWritesBlocked();
    }

    tester.testSingleWrite();
    return tester.success();
}

bool doTestsBlockedAndUnblocked(bool setMaxProductSize,
                                size_t maxRowsPerSegment = 0)
{
    bool success = true;
    if (!doTests<nitf::Uint8>(true, setMaxProductSize, maxRowsPerSegment))
    {
        success = false;
    }
    if (!doTests<nitf::Uint8>(false, setMaxProductSize, maxRowsPerSegment))
    {
        success = false;
    }

    // Only 1 byte per pixel supported for now
    return success;
}
}

int main(int /*argc*/, char** /*argv*/)
{
    try
    {
        bool success = true;
        if (!doTestsBlockedAndUnblocked(false))
        {
            success = false;
        }

        // Run tests forcing various numbers of segments
        // Blocking is set at 40 rows / block so can't go less than this
        // Actual limit is a bit higher, since j2k needs a minimum size
        std::vector<size_t> numRows;
        numRows.push_back(100);
        numRows.push_back(80);
        numRows.push_back(50);

        for (size_t ii = 0; ii < numRows.size(); ++ii)
        {
            if (!doTestsBlockedAndUnblocked(true, numRows[ii]))
            {
                success = false;
                break;
            }
        }

        if (success)
        {
            std::cout << "All tests passed\n";
        }
        else
        {
            std::cerr << "Some tests failed\n";
        }

        return (success ? 0 : 1);
    }
    catch (const std::exception& ex)
    {
        std::cerr << "Caught std::exception: " << ex.what() << std::endl;
        return 1;
    }
    catch (const except::Exception& ex)
    {
        std::cerr << "Caught except::Exception: " << ex.getMessage()
                  << std::endl;
        return 1;
    }
    catch (...)
    {
        std::cerr << "Caught unknown exception\n";
        return 1;
    }
}
