/* =========================================================================
 * This file is part of six-c++ 
 * =========================================================================
 * 
 * (C) Copyright 2004 - 2009, General Dynamics - Advanced Information Systems
 *
 * six-c++ is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public 
 * License along with this program; If not, 
 * see <http://www.gnu.org/licenses/>.
 *
 */
#include "six/ExploitationFeatures.h"

using namespace six;

InputROI::InputROI(double nr, double nc, double fr, double fc)
{
    size.row = nr;
    size.col = nc;
    upperLeft.row = fr;
    upperLeft.col = fc;
}

InputROI* InputROI::clone() const
{
    InputROI* roi = new InputROI(*this);
    return roi;
}

TxRcvPolarization::TxRcvPolarization(PolarizationType tx, double rcv)
{
    txPolarization = tx;
    rcvPolarization = rcv;
}

TxRcvPolarization* TxRcvPolarization::clone() const
{
    TxRcvPolarization* pol = new TxRcvPolarization(this->txPolarization,
                                                   this->rcvPolarization);
    return pol;
}

Information::Information()
{
    //! TODO: Should we set this to SPOTLIGHT?
    sensorName = Init::undefined<std::string>();
    radarMode = Init::undefined<RadarModeType>();
    radarModeID = Init::undefined<std::string>();
    localDateTime = Init::undefined<std::string>();
    collectionDuration = Init::undefined<double>();
    resolution = Init::undefined<RangeAzimuth<double> >();
    inputROI = NULL;
    polarization = NULL;
}

Information::~Information()
{
    if (inputROI)
        delete inputROI;
    if (polarization)
        delete polarization;
}

Information* Information::clone() const
{
    Information* i = new Information();
    i->radarMode = radarMode;
    i->collectionDateTime = collectionDateTime;
    i->localDateTime = Init::undefined<std::string>();
    i->collectionDuration = collectionDuration;
    i->resolution = resolution;
    if (inputROI)
        i->inputROI = inputROI->clone();
    if (polarization)
        i->polarization = polarization->clone();
    return i;
}

Geometry::Geometry()
{
    azimuth = Init::undefined<double>();
    slope = Init::undefined<double>();
    squint = Init::undefined<double>();
    graze = Init::undefined<double>();
    tilt = Init::undefined<double>();
}

Geometry* Geometry::clone() const
{
    return new Geometry(*this);
}

Phenomenology::Phenomenology()
{
    shadow = Init::undefined<AngleMagnitude>();
    layover = Init::undefined<AngleMagnitude>();
    multiPath = Init::undefined<double>();
    groundTrack = Init::undefined<double>();
}

Phenomenology* Phenomenology::clone() const
{
    return new Phenomenology(*this);
}

Collection::~Collection()
{
    if (information)
        delete information;
    if (geometry)
        delete geometry;
    if (phenomenology)
        delete phenomenology;
}

Collection* Collection::clone() const
{
    Collection* c = new Collection();
    c->identifier = identifier;
    if (information)
        c->information = information->clone();

    if (geometry)
        c->geometry = geometry->clone();

    if (phenomenology)
        c->phenomenology = phenomenology->clone();

    return c;
}

Product::Product()
{
    resolution = Init::undefined<RowColDouble>();
    north = Init::undefined<double>();
}

ExploitationFeatures::~ExploitationFeatures()
{
    for (unsigned int i = 0; i < collections.size(); ++i)
    {
        Collection* c = collections[i];
        delete c;
    }
}

ExploitationFeatures::ExploitationFeatures(unsigned int numCollections)
{
    for (unsigned int i = 0; i < numCollections; ++i)
    {
        Collection* c = new Collection();
        collections.push_back(c);
    }
}

ExploitationFeatures* ExploitationFeatures::clone() const
{
    ExploitationFeatures* ef = new ExploitationFeatures();
    for (unsigned int i = 0; i < collections.size(); ++i)
    {
        Collection* c = collections[i];
        ef->collections.push_back(c->clone());
    }
    return ef;
}
