/* =========================================================================
 * This file is part of six.sidd-c++
 * =========================================================================
 *
 * (C) Copyright 2004 - 2014, MDA Information Systems LLC
 *
 * six.sidd-c++ is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; If not,
 * see <http://www.gnu.org/licenses/>.
 *
 */
#include "six/sidd/ExploitationFeatures.h"

using namespace six;
using namespace six::sidd;

InputROI::InputROI(double nr, double nc, double fr, double fc) :
    size(nr, nc),
    upperLeft(fr, fc)
{
}

InputROI* InputROI::clone() const
{
    return new InputROI(*this);
}

TxRcvPolarization::TxRcvPolarization(PolarizationType tx, PolarizationType rcv,
                                     double rcvOffset) :
    txPolarization(tx),
    rcvPolarization(rcv),
    rcvPolarizationOffset(rcvOffset),
    processed(Init::undefined<BooleanType>())
{
}

TxRcvPolarization::TxRcvPolarization(PolarizationType tx, 
                                     PolarizationType rcv) :
    txPolarization(tx),
    rcvPolarization(rcv),
    rcvPolarizationOffset(Init::undefined<double>()),
    processed(Init::undefined<BooleanType>())
{
}

TxRcvPolarization* TxRcvPolarization::clone() const
{
    return new TxRcvPolarization(*this);
}

Information::Information() :
    sensorName(Init::undefined<std::string>()),
    radarMode(Init::undefined<RadarModeType>()),
    radarModeID(Init::undefined<std::string>()),
    localDateTime(Init::undefined<std::string>()),
    collectionDuration(Init::undefined<double>()),
    resolution(Init::undefined<types::RgAz<double> >())
{
    //! TODO: Should we set sensorName to SPOTLIGHT?
}

Information* Information::clone() const
{
    return new Information(*this);
}

bool Information::operator==(const Information& rhs) const
{
    return (sensorName == rhs.sensorName &&
        radarMode == rhs.radarMode &&
        radarModeID == rhs.radarModeID &&
        collectionDateTime == rhs.collectionDateTime &&
        localDateTime == rhs.localDateTime &&
        collectionDuration == rhs.collectionDuration &&
        resolution == rhs.resolution &&
        inputROI == rhs.inputROI &&
        polarization == rhs.polarization);
}

Geometry::Geometry() :
    azimuth(Init::undefined<double>()),
    slope(Init::undefined<double>()),
    squint(Init::undefined<double>()),
    graze(Init::undefined<double>()),
    tilt(Init::undefined<double>())
{
}

Geometry* Geometry::clone() const
{
    return new Geometry(*this);
}

bool Geometry::operator==(const Geometry& rhs) const
{
    return (azimuth == rhs.azimuth &&
        slope == rhs.slope &&
        squint == rhs.squint &&
        graze == rhs.graze &&
        tilt == rhs.tilt &&
        extensions == rhs.extensions);
}

Phenomenology::Phenomenology() :
    shadow(Init::undefined<AngleMagnitude>()),
    layover(Init::undefined<AngleMagnitude>()),
    multiPath(Init::undefined<double>()),
    groundTrack(Init::undefined<double>())
{
}

Phenomenology* Phenomenology::clone() const
{
    return new Phenomenology(*this);
}

Collection* Collection::clone() const
{
    return new Collection(*this);
}

Product::Product() :
    resolution(Init::undefined<RowColDouble>()),
    north(Init::undefined<double>())
{
}

ExploitationFeatures::ExploitationFeatures(size_t numCollections)
{
    collections.resize(numCollections);
    for (size_t i = 0; i < numCollections; ++i)
    {
        collections[i].reset(new Collection());
    }
}

ExploitationFeatures* ExploitationFeatures::clone() const
{
    return new ExploitationFeatures(*this);
}

