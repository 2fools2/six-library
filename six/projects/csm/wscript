MAINTAINER         = 'adam.sylvester@mdaus.com'
VERSION            = '1.1.2'
MODULE_DEPS        = 'six.sicd six.sidd'
PLUGIN             = 'CSM'
REMOVEPLUGINPREFIX = True

import sys, os, re
from waflib import Errors, Options, Logs

DIRS = 'external'

def options(opt):
    opt.recurse(DIRS)

def configure(conf):
    conf.recurse(DIRS)

    # See previous revisions for special compiler and linker flags that were
    # needed to work properly with Socet GXP 3.2 on Windows

    # Get the platform name
    # TODO: Should beef up the Linux and Solaris naming conventions
    enableCSM = Options.options.enable_csm
    if enableCSM:
        linuxRegex = r'.*-.*-linux-.*|i686-pc-.*|linux'
        solarisRegex = r'sparc-sun.*|i.86-pc-solaris.*|sunos'
        winRegex = r'win32'
        osxRegex = r'darwin'
        if re.match(linuxRegex, sys.platform):
            platformName = 'linux'
        elif re.match(solarisRegex, sys.platform):
            platformName = 'solaris'
        elif re.match(winRegex, sys.platform):
            # NOTE: When there are multiple versions of VS installed, even if you
            #       run in the VS command prompt that puts that version of VS first
            #       on the path, to really get waf to set env['MSVC_VERSION']
            #       properly, you may need to call out --msvc_version explicitly
            #       at configure time (otherwise I think msvc.py picks a different
            #       one but you end up with the one from the command prompt since
            #       it's first on your path).
            #       For example, if you're building with VS 2008 Express, use:
            #       --enable-32bit "--msvc_version=msvc 9.0Exp"
            if 'MSVC_VERSION' in conf.env:
                platformName = 'winVC' + str(conf.env['MSVC_VERSION']).replace('.', '')
            else:
                # If we are building with gcc on Windows, some of the CSM stuff
                # doesn't compile.  No one is going to ever need to build CSM
                # plugins in this paradigm as MSP and GXP won't be able to use
                # them anyhow
                enableCSM = False
        elif re.match(osxRegex,sys.platform):
            # The CSM build doesn't work on Mac... again, no one will need to build
            # plugins there though
            platformName='darwin'
            enableCSM = False
        else:
            raise Errors.WafError('Unsupported platform %s' % sys.platform)

        if enableCSM:
            pluginVersion = '113'
            csmVersion = '301'
            conf.env['SIX_CSM_PLATFORM_NAME'] = 'SIX_SAR_MDAIS_' + pluginVersion + '_' + platformName + '_CSM' + csmVersion
        else:
            Logs.warn('Disabling CSM as it is not supported on this platform')

def build(bld):
    if 'SIX_CSM_PLATFORM_NAME' in bld.env:
        bld.recurse(DIRS)

        # NOTE: When we can (i.e. on Unix), use just the CSM headers rather than
        #       just use=CSMAPI so that we don't have a needless dependency on
        #       the CSM shared object.  On Windows we are stuck.
        name = bld.env['SIX_CSM_PLATFORM_NAME']
        modArgs = globals()
        modArgs['NAME'] = name
        modArgs['LIBNAME'] = name
        if re.match(r'win32', sys.platform):
            modArgs['USE'] = 'CSMAPI'
        else:
            modArgs['INCLUDES'] = ['include', bld.env['INCLUDES_CSM']]
        bld.plugin(**modArgs)
    
        bld.program_helper(module_deps='six.sicd',
                               source='tests/test_sicd_csm.cpp',
                               use='CSMAPI',
                               name='test_sicd_csm')
    
        bld.program_helper(module_deps='scene six.sidd',
                               source='tests/test_sidd_csm.cpp',
                               use='CSMAPI',
                               name='test_sidd_csm')
    
    
        # TODO: It seems like instead of this, I should be able to set
        #       modArgs['TARGETNAME'] to 'six-csm' and have that just be the
        #       name of the target.  This works fine when building, but 
        #       something about how 'waf list' and 'waf msvs' operate makes this
        #       not work right.
        bld(features='add_targets', target='six-csm',
            targets_to_add=name)

def distclean(context):
    context.recurse(DIRS)
